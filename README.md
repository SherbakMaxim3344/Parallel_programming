# Parallel_programming
# 1. Блочное умножение матриц
## Теория
- Параллельные вычисления — это тип вычислений, при котором одновременно выполняется множество операций или процессов. Большие проблемы часто можно разделить на более мелкие, которые затем могут быть решены одновременно, и, как следствие, большая проблема будет решена при таком подходе гораздо быстрее.
- Процесс на компьютере — это любое отдельно запущенное приложение.
- Один процесс может порождать несколько потоков (Threads), которые будут выполняться одновременно и параллельно.
- Современные компьютеры имеют продвинутые процессоры, у которых есть по несколько ядер. Каждое отдельное ядро способно обработать минимум один поток. Теперь научились делать ядра многопоточными, а это означает, что одно ядро может одновременно выполнять несколько команд в соответствии с числом ядерных потоков. Грубо говоря, если в одном ядре 4 ядерных потока, то ядро может выполнить одновременно 4 команды.
```bash
lscpu 
```
покажет 
- CPU(s) - общее количество логических процессоров (потоков)
- Core(s) per socket - ядер на сокет
- Thread(s) per core - потоков на ядро
- Socket(s) - количество сокетов (физических процессоров)

в моем случае:
- CPU(s):                   8
- Потоков на ядро:      2
- Ядер на сокет:        4

### Пул потоков (Thread Pool) — это фиксированный набор потоков, одновременно выполняющих независимые друг от друга задачи, помещенные в некоторый массив. Массив задач обычно представляется в виде очереди (Task Queue).
- Основное назначение пула потоков — обратить "сырую" многопоточную обработку в удобный инструмент эффективного решения трудоемких задач, допускающих разбиение на независимые кусочки.
- Ключевым аспектом логики работы Thread Pool'а является факт того, что все потоки запускаются единожды.

### Работа с потоками
Для работы с потоками нам пригодится класс std::thread, определенный в заголовочном файле <thread>
Для того, чтобы "дождаться" завершения работы потока (выхода из переданной ему функции) используется метод std::thread::join(). Также, стоит отметить, что вместо std::thread::join() может быть использован метод std::thread::detach()

## Ассинхронное
std::async и std::future - это механизмы для асинхронного выполнения задач в C++ (начиная с C++11), которые предоставляют более высокоуровневый интерфейс по сравнению с непосредственной работой с потоками.
std::future - это шаблонный класс, который представляет собой отложенное значение, которое будет вычислено в будущем.
std::async запускает асинхронную задачу (в отдельном потоке или на одном потоке, в зависимости от реализации), а std::future предоставляет объект для последующего получения результата этой задачи или для ожидания ее завершения, позволяя организовать асинхронную работу с вычислениями 
std::async - функция для запуска асинхронной задачи, которая возвращает std::future с результатом.

- Параллелизм - это когда несколько задач выполняются одновременно на разных ядрах/процессорах.
- Асинхронность - это когда задачи не блокируют основной поток, но не обязательно выполняются одновременно.

## Задача
- 1.1 Использовать std::thread для создания потоков. Провести исследование метрик производительности в зависимости от количества потоков и в зависимости от размера задачи, выбрать количество потоков при котором достигается оптимальная производительность.
- 1.2 Использовать std::async и std::future.

## Алгорит блочного умножения
### Идея:
Вместо умножения матриц поэлементно, матрицы делятся на блоки. Результирующая матрица формируется блоками — каждый блок вычисляется как сумма произведений соответствующих под-блоков исходных матриц.

### Как работает:
- 1. Разбиение на блоки:
Матрица A и B делятся на подматрицы (блоки) размера blockSize × blockSize. Если размер матрицы не кратен blockSize, крайние блоки могут быть меньше.
- 2. Умножение блоков:
Для каждого блока результирующей матрицы res берётся соответствующий ряд блоков из A и столбцов блоков из B. Произведение этих блоков суммируется, чтобы получить значение блока в res.
- 3. Сборка результата:
После обработки всех комбинаций блоков, полученные блоки результирующей матрицы объединяются, формируя полную матрицу res = A * B.

### Пример:
```bash
Матрица A (4×4):
[ 1  2  3  4 ]
[ 5  6  7  8 ]
[ 9 10 11 12 ]
[13 14 15 16 ]

Матрица B (4×4):
[17 18 19 20]
[21 22 23 24]
[25 26 27 28]
[29 30 31 32]
```
Матрица A разбивается на 4 блока:
```bash
A11 = [1  2]   A12 = [3  4]
      [5  6]         [7  8]

A21 = [9  10]  A22 = [11 12]
      [13 14]        [15 16]
```
Матрица B разбивается на 4 блока:
```bash
B11 = [17 18]  B12 = [19 20]
      [21 22]        [23 24]

B21 = [25 26]  B22 = [27 28]
      [29 30]        [31 32]
```
Процесс умножения блоков:
```bash
C11 = A11×B11 + A12×B21
C12 = A11×B12 + A12×B22  
C21 = A21×B11 + A22×B21
C22 = A21×B12 + A22×B22
```

### как это работает в коде
-  Определение количества блоков
```bash
// В функции multiplyBlockedThreads:
std::vector<BlockTask> tasks;
for (int i = 0; i < n; i += blockSize) {
    for (int j = 0; j < n; j += blockSize) {
        tasks.push_back(BlockTask{i, j});
    }
}
```

blockSize - это размер подматрицы (блока)

в коде все данные задаются вот так
```bash
    std::vector<int> numThreads = {1, 2, 4, 8, 12, 16};
    std::vector<int> matrixSizes = {256, 512, 1024};
    std::vector<int> blockSizes = {16, 32, 64, 128};
```
### Класс и функции
1. Класс Matrix
   
Конструкторы:
```bash
// Конструктор со случайными значениями
Matrix(size_t n, int minVal, int maxVal) : n(n) {
    std::random_device rd;           // Источник энтропии
    std::mt19937 gen(rd());          // Генератор Mersenne Twister
    std::uniform_int_distribution<int> dist(minVal, maxVal); // Равномерное распределение

    data.resize(n, std::vector<int>(n));  // Создаем n x n матрицу
    for (size_t i = 0; i < n; ++i) {
        for (size_t j = 0; j < n; ++j) {
            data[i][j] = dist(gen);  // Заполняем случайными числами
        }
    }
}

// Конструктор с постоянным значением
Matrix(size_t n, int value) : n(n) {
    data.resize(n, std::vector<int>(n, value));  // Все элементы = value
}
```
2. Блочное умножение - ключевые функции

Структура задачи блока:
```bash
struct BlockTask {
    int i, j;  // Координаты ЛЕВОГО ВЕРХНЕГО угла блока в результирующей матрице
};
```
Создание задач:
```bash
std::vector<BlockTask> tasks;
for (int i = 0; i < n; i += blockSize) {
    for (int j = 0; j < n; j += blockSize) {
        tasks.push_back(BlockTask{i, j});
    }
}
```
Пример для n=4, blockSize=2:
```bash
Задачи: 
(0,0), (0,2), (2,0), (2,2)  // 4 блока
```
